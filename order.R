help(order)
"S??? miêu t???
order tr??? v??? m???t hoán v??? s???p x???p l???i d???i s??? d???u tiên c???a nó thành th??? t??? tang d???n ho???c gi???m d???n, phá v??? m???i quan h??? b???ng các d???i s??? khác. sort.list cung làm nhu v???y, ch??? s??? d???ng m???t d???i s???.
Xem các ví d??? d??? bi???t cách s??? d???ng các hàm này d??? s???p x???p các khung d??? li???u, v.v.
S??? d???ng"
order(..., na.last = TRUE, decreasing = FALSE,
      method = c("auto", "shell", "radix"))

sort.list(x, partial = NULL, na.last = TRUE, decreasing = FALSE,
          method = c("auto", "shell", "quick", "radix"))
"Tranh lu???n
...
m???t chu???i các vecto s???, ph???c, ký t??? ho???c lôgic, t???t c??? d???u có cùng d??? dài ho???c m???t d???i tu???ng R du???c phân lo???i.
x
m???t vector nguyên t??? cho các phuong th???c "shell" và "quick". Khi x là d???i tu???ng R không ph???i nguyên t???, các phuong th???c "t??? d???ng" và "co s???" m???c d???nh có th??? ho???t d???ng n???u th??? t??? (x, ..) có.
partial
vecto c???a các ch??? s??? d??? s???p x???p t???ng ph???n. (Các giá tr??? không ph???i NULL không du???c tri???n khai.)
decreasing
h???p lý. Th??? t??? s???p x???p nên tang hay gi???m? D???i v???i phuong th???c "co s???", dây có th??? là m???t vecto có d??? dài b???ng s??? d???i s??? trong .... D???i v???i các phuong th???c khác, nó ph???i có d??? dài b???ng m???t.
na.last
d??? ki???m soát vi???c d???i x??? v???i NAs. N???u TRUE, các giá tr??? b??? thi???u trong d??? li???u du???c d???t cu???i cùng; n???u FALSE, chúng du???c d???t tru???c; n???u NA, chúng s??? b??? xóa (xem ph???n "Luu ý".)
method
phuong pháp du???c s??? d???ng: cho phép các k???t qu??? phù h???p t???ng ph???n. Giá tr??? m???c d???nh ("t??? d???ng") ng??? ý "co s???" cho các vecto s??? ng???n, vecto s??? nguyên, vecto logic và h??? s???. N???u không, nó bao hàm "shell". D??? bi???t chi ti???t v??? các phuong th???c "shell", "quick" và "radix", hãy xem ph???n tr??? giúp d??? s???p x???p."
"Chi ti???t
Trong tru???ng h???p liên k???t trong vecto d???u tiên, các giá tr??? trong vecto th??? hai du???c s??? d???ng d??? phá v??? các ràng bu???c. N???u các giá tr??? v???n b??? ràng bu???c, các giá tr??? trong các d???i s??? sau này du???c s??? d???ng d??? phá v??? ràng bu???c (xem ví d??? d???u tiên). Lo???i du???c s??? d???ng là ???n d???nh (ngo???i tr??? method = "quick"), vì v???y m???i ràng bu???c chua du???c gi???i quy???t s??? du???c gi??? nguyên theo th??? t??? ban d???u c???a chúng.
Các giá tr??? ph???c t???p du???c s???p x???p d???u tiên theo ph???n th???c, sau dó là ph???n ???o.
Ngo???i tr??? phuong th???c "co s???", th??? t??? s???p x???p cho các vecto ký t??? s??? ph??? thu???c vào trình t??? d???i chi???u c???a ngôn ng??? du???c s??? d???ng: xem So sánh.
Phuong pháp "shell" nói chung là d???t cu???c an toàn nh???t và là phuong pháp m???c d???nh, ngo???i tr??? các th???a s??? ng???n, vecto s???, vecto s??? nguyên và vecto logic, trong dó "co s???" du???c gi??? d???nh. Phuong pháp "co s???" s???p x???p ???n d???nh các vecto logic, s??? và ký t??? trong th???i gian tuy???n tính. Nó ho???t d???ng t???t hon các phuong pháp khác, m???c dù có nh???ng luu ý (xem ph???n s???p x???p). Phuong th???c "quick" cho sort.list ch??? du???c h??? tr??? cho s??? x v???i na.last = NA, không ???n d???nh và ch???m hon "co s???".
m???t ph???n = NULL du???c h??? tr??? d??? tuong thích v???i các tri???n khai khác c???a S, nhung không có giá tr??? nào khác du???c ch???p nh???n và vi???c s???p x???p luôn hoàn t???t.
D???i v???i m???t d???i tu???ng R du???c phân l???p, th??? t??? s???p x???p du???c l???y t??? xtfrm: nhu trang tr??? giúp c???a nó ghi chú, di???u này có th??? ch???m tr??? khi m???t phuong th???c phù h???p dã du???c xác d???nh ho???c is.numeric (x) là dúng. D???i v???i các y???u t???, di???u này s???p x???p theo mã n???i b???, d???c bi???t thích h???p cho các y???u t??? có th??? t???.
Giá tr???
M???t vecto s??? nguyên tr??? khi b???t k??? d???u vào nào có 2 ^ 31 ph???n t??? tr??? lên, khi nó là m???t vecto kép.
C???nh báo
Trong s??? d???ng theo chuong trình, không an toàn khi d???t tên cho các d???i s??? ..., vì tên có th??? kh???p v???i các d???i s??? di???u khi???n hi???n t???i ho???c trong tuong lai, ch???ng h???n nhu gi???m d???n. M???t th???c t??? không an toàn dôi khi g???p ph???i là g???i do.call ('order', df_obj) trong dó df_obj có th??? là m???t khung d??? li???u: sao chép df_obj và xóa b???t k??? tên nào, ch???ng h???n nhu s??? d???ng unname.
Ghi chú
sort.list có th??? b??? g???i nh???m nhu m???t phuong th???c d??? s???p x???p v???i d???i s??? danh sách: nó dua ra m???t thông báo l???i phù h???p cho danh sách x.
Có m???t s??? khác bi???t l???ch s??? v??? hành vi d???i v???i na.last = NA: sort.list xóa các NA và sau dó tính th??? t??? gi???a các ph???n t??? còn l???i: order tính th??? t??? gi???a các ph???n t??? không ph???i NA c???a vecto ban d???u. Nhu v???y"
x[order(x, na.last = NA)]
zz <- x[!is.na(x)]; zz[sort.list(x, na.last = NA)]
c??? hai s???p x???p các giá tr??? không ph???i NA c???a x.

Tru???c R 3.3.0 method = "radix" ch??? du???c h??? tr??? cho các s??? nguyên có ph???m vi nh??? hon 100.000.
"Ngu???i gi???i thi???u
Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) The New S Language. Wadsworth & Brooks/Cole.
Knuth, D. E. (1998) The Art of Computer Programming, Volume 3: Sorting and Searching. 2nd ed. Addison-Wesley."
"các ví d???"
require(stats)

(ii <- order(x <- c(1,1,3:1,1:4,3), y <- c(9,9:1), z <- c(2,1:9)))
## 6  5  2  1  7  4 10  8  3  9
rbind(x, y, z)[,ii] # shows the reordering (ties via 2nd & 3rd arg)

## Suppose we wanted descending order on y.
## A simple solution for numeric 'y' is
rbind(x, y, z)[, order(x, -y, z)]
## More generally we can make use of xtfrm
cy <- as.character(y)
rbind(x, y, z)[, order(x, -xtfrm(cy), z)]
## The radix sort supports multiple 'decreasing' values:
rbind(x, y, z)[, order(x, cy, z, decreasing = c(FALSE, TRUE, FALSE),
                       method="radix")]

## Sorting data frames:
dd <- transform(data.frame(x, y, z),
                z = factor(z, labels = LETTERS[9:1]))
## Either as above {for factor 'z' : using internal coding}:
dd[ order(x, -y, z), ]
## or along 1st column, ties along 2nd, ... *arbitrary* no.{columns}:
dd[ do.call(order, dd), ]

set.seed(1)  # reproducible example:
d4 <- data.frame(x = round(   rnorm(100)), y = round(10*runif(100)),
                 z = round( 8*rnorm(100)), u = round(50*runif(100)))
(d4s <- d4[ do.call(order, d4), ])
(i <- which(diff(d4s[, 3]) == 0))
#   in 2 places, needed 3 cols to break ties:
d4s[ rbind(i, i+1), ]

## rearrange matched vectors so that the first is in ascending order
x <- c(5:1, 6:8, 12:9)
y <- (x - 5)^2
o <- order(x)
rbind(x[o], y[o])

## tests of na.last
a <- c(4, 3, 2, NA, 1)
b <- c(4, NA, 2, 7, 1)
z <- cbind(a, b)
(o <- order(a, b)); z[o, ]
(o <- order(a, b, na.last = FALSE)); z[o, ]
(o <- order(a, b, na.last = NA)); z[o, ]


##  speed examples on an average laptop for long vectors:
##  factor/small-valued integers:
x <- factor(sample(letters, 1e7, replace = TRUE))
system.time(o <- sort.list(x, method = "quick", na.last = NA)) # 0.1 sec
stopifnot(!is.unsorted(x[o]))
system.time(o <- sort.list(x, method = "radix")) # 0.05 sec, 2X faster
stopifnot(!is.unsorted(x[o]))
##  large-valued integers:
xx <- sample(1:200000, 1e7, replace = TRUE)
system.time(o <- sort.list(xx, method = "quick", na.last = NA)) # 0.3 sec
system.time(o <- sort.list(xx, method = "radix")) # 0.2 sec
##  character vectors:
xx <- sample(state.name, 1e6, replace = TRUE)
system.time(o <- sort.list(xx, method = "shell")) # 2 sec
system.time(o <- sort.list(xx, method = "radix")) # 0.007 sec, 300X faster
##  double vectors:
xx <- rnorm(1e6)
system.time(o <- sort.list(xx, method = "shell")) # 0.4 sec
system.time(o <- sort.list(xx, method = "quick", na.last = NA)) # 0.1 sec
system.time(o <- sort.list(xx, method = "radix")) # 0.05 sec, 2X faster